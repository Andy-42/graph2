package andy42.graph.model

import org.msgpack.core.{MessagePacker, MessageUnpacker}
import zio.{IO, ZIO}
import java.io.IOException

import scala.reflect.ClassTag
import org.msgpack.value.ValueType

trait Packable {
  /**
   * Write self to packer and return packer.
   */
  def pack(packer: MessagePacker): MessagePacker
}

sealed trait UnpackFailure extends Throwable

// A failure generated by MessagePack
case class DecodingFailure(ioe: IOException) extends UnpackFailure
// Enumerated discriminators
case class UnexpectedDiscriminator(discriminator: Byte, field: String) extends UnpackFailure
case class UnexpectedValueType(valueType: ValueType, context: String) extends UnpackFailure

object UnpackFailure {
  val refine: PartialFunction[UnpackFailure | Throwable, UnpackFailure] = {
    case unpackFailure: UnpackFailure => unpackFailure
    case ioe: IOException => DecodingFailure(ioe)
  }
}

trait Unpackable[T] {
  /**
   * Unpack a T. This can fail, so this is effectful.
   */
  def unpack(unpacker: MessageUnpacker): IO[UnpackFailure, T]
}

object UnpackOperations {

  def unpackToVector[T: ClassTag](unpackElement: => IO[UnpackFailure, T], length: Int): IO[UnpackFailure, Vector[T]] = {

    val a: Array[T] = Array.ofDim[T](length)

    def accumulate(i: Int = 0): IO[UnpackFailure, Vector[T]] =
      if (i == length)
        ZIO.succeed(a.toVector)
      else
        unpackElement.flatMap { t =>
          a(i) = t
          accumulate(i + 1)
        }

    accumulate()
  }

  def unpackToMap[K, V](unpackEntry: => IO[UnpackFailure, (K, V)], length: Int): IO[UnpackFailure, Map[K, V]] = {

    def accumulate(i: Int = 0, r: Map[K, V] = Map.empty): IO[UnpackFailure, Map[K, V]] =
      if (i == length)
        ZIO.succeed(r)
      else
        unpackEntry.flatMap { entry =>
          accumulate(i + 1, r + entry)
        }

    accumulate()
  }
}