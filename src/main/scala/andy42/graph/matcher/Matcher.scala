package andy42.graph.matcher

import andy42.graph.model.*
import andy42.graph.services.{Graph, PersistenceFailure}
import zio.*

import scala.annotation.tailrec

type NodeSpecName = String
case class SpecNodeMatch(specName: NodeSpecName, id: NodeId)

type ResolvedMatches = Map[SpecNodeMatch, Dependencies]
type ResolvedMatchEntry = (SpecNodeMatch, Dependencies)

object ResolvedMatches:
  val empty: ResolvedMatches = Map.empty

extension (resolvedMatches: ResolvedMatches) def isSimpleCase: Boolean = resolvedMatches.forall(_._2.isSimpleCase)

/** The spec-node match that must be valid matches for some spec-node match to be valid. This is generated by matching
  * each edge of the node against the edge spec. The outer vector corresponds to the edge spec in the node. The inner
  * vector represents each of the edges in the node that matches this specification.
  *
  * A Dependencies to be valid (i.e., part of a valid proof for a spec-node match), each element must have at least one
  * element.
  *
  * If there is more than one element for a spec-edge match, then there are multiple combinations of node matches that
  * satisfy the constraints of the subgraph specification. In the simple case where each spec-edge match has exactly one
  * element, the output is the SpecNodeMatches of the keys. TODO: Move this to ResolvedMatches
  */
type Dependencies = Vector[Vector[SpecNodeMatch]]

extension (dependencies: Dependencies)

  /** A Dependencies is valid if all edge specs have at least one proven (or at least, not-yet-proven element). */
  def isValid: Boolean = dependencies.nonEmpty && dependencies.forall(_.nonEmpty)

  /** The simple case for generating output requires that each edge has exactly one element. */
  def isSimpleCase: Boolean = dependencies.forall(_.length == 1)

trait Matcher:

  def matchNodes(ids: Vector[NodeId]): NodeIO[Vector[ResolvedMatches]]

case class MatcherLive(subgraphSpec: SubgraphSpec, nodeSnapshotCache: MatcherSnapshotCache) extends Matcher:

  /** Match the given nodes using each node spec in the subgraph spec as a starting point.
    * @param ids
    *   The ids of the nodes to be matched.
    * @return
    *   The successfully resolved matches between the given nodes and the nodes in the spec. This result may contain
    *   duplicate matches.
    */
  override def matchNodes(ids: Vector[NodeId]): NodeIO[Vector[ResolvedMatches]] =
    for
      snapshots <- ZIO.foreachPar(ids)(nodeSnapshotCache.get)
      potentialMatches = shallowMatchesInCrossProduct(ids, snapshots)
      resolvedMatches <- ZIO.foreachPar(potentialMatches) { potentialMatch =>
        prove(resolvedMatches = Map(potentialMatch), keysToProve = potentialMatch.unprovenDependenciesFromSelf)
      }
    yield resolvedMatches.filter(_.nonEmpty)

  /** Create an initial match for each spec-node pair that shallow matches.
    * @param ids
    *   The ids of the nodes to be evaluated.
    * @param snapshots
    *   The corresponding node snapshot for node id.
    * @return
    *   An initial match, where the key is the spec-node that shallow matched, and the value is the node-id pair
    *   dependencies that must also match for this spec-node pair to be proven true.
    */
  def shallowMatchesInCrossProduct(ids: Vector[NodeId], snapshots: Vector[NodeSnapshot]): Vector[ResolvedMatchEntry] =
    for
      (id, snapshot) <- ids.zip(snapshots)
      nodeSpec <- subgraphSpec.allUniqueNodeSpecs
      dependencies = nodeSpec.shallowMatchNode(using snapshot)
      if dependencies.isValid
    yield SpecNodeMatch(nodeSpec.name, id) -> dependencies

  /** Expand the proof for a node by traversing its unproven dependencies.
    *
    * The node-id keys matches are tested using shallow matching.
    *
    * Any failed matches have their dependencies removed from resolved matches. That dependency results in an invalid
    * dependency (i.e., one or more edges now has zero matches), then that entry is removed from resolved matches in the
    * next recursion. If resolved matches becomes empty, then the original spec-node being proven has failed to be
    * proven, so the overall match fails.
    *
    * If the match has not failed, then the proven spec-node pairs are added to resolvedMatches. This may add new
    * unproven matches that are proven on the next recursion.
    *
    * @param resolvedMatches
    *   A map with spec-node pairs as keys, and that nodes dependencies as value.
    * @param keysToProve
    *   The keys to be proven on this iteration.
    * @return
    *   A map containing the full proof of the initial spec-node pair. If empty, the match has failed; otherwise the map
    *   represents the fully-proven match.
    */
  def prove(
      resolvedMatches: ResolvedMatches,
      keysToProve: Vector[SpecNodeMatch]
  ): NodeIO[ResolvedMatches] =
    nodeSnapshotCache.fetchSnapshots(keysToProve.map(_.id)).flatMap { snapshots =>

      val (successfulMatches: Vector[ResolvedMatchEntry], failedMatches) =
        keysToProve
          .zip(snapshots)
          .map((key, snapshot) => key -> subgraphSpec.nameToNodeSpec(key.specName).shallowMatchNode(using snapshot))
          .partition(_.dependentMatches.isValid)

      // Remove dis-proven matches from resolved.
      // If resolved matches becomes empty, then the match on the origin node has failed.
      val resolvedMatchesWithFailuresRemoved = removeMatches(resolvedMatches, failedMatches.map(_.matchKey))

      if resolvedMatchesWithFailuresRemoved.isEmpty then ZIO.succeed(ResolvedMatches.empty)
      else
        val nextResolvedMatches = resolvedMatchesWithFailuresRemoved ++ successfulMatches
        val nextKeysToProve = nextResolvedMatches.unprovenDependenciesFrom(successfulMatches)

        if nextKeysToProve.isEmpty then ZIO.succeed(nextResolvedMatches)
        else prove(nextResolvedMatches, nextKeysToProve)
    }

  /** Remove a matches that have failed from resolved matches.
    *
    * @param resolvedMatches
    *   The resolved matched to have keys removed.
    * @param keysToRemove
    *   The spec-node keys to be removed.
    * @return
    *   resolvedMatches with keys removed.
    */
  def removeMatches(resolvedMatches: ResolvedMatches, keysToRemove: Vector[SpecNodeMatch]): ResolvedMatches =

    @tailrec def accumulate(
        keysToRemove: Vector[SpecNodeMatch] = keysToRemove,
        resolvedMatches: Map[SpecNodeMatch, Dependencies] = resolvedMatches
    ): ResolvedMatches =
      // Remove invalid entries first - discover overall failure of the match as soon as possible.
      val (validEntries, invalidEntries) = resolvedMatches
        .map(resolvedMatchEntry =>
          if resolvedMatchEntry.dependentMatches.exists(_.exists(keysToRemove.contains(_))) then
            resolvedMatchEntry.matchKey -> resolvedMatchEntry.dependentMatches.map(_.filter(!keysToRemove.contains(_)))
          else resolvedMatchEntry
        )
        .partition(_.dependentMatches.isValid)

      if validEntries.isEmpty then Map.empty // match has failed
      else if invalidEntries.isEmpty then validEntries // all keys have been removed
      else accumulate(invalidEntries.keys.toVector, validEntries) // more removing to do

    if keysToRemove.isEmpty then resolvedMatches else accumulate()

  extension (nodeSpec: NodeSpec)
    def shallowMatchNode(using snapshot: NodeSnapshot): Dependencies =
      if !nodeSpec.allPredicatesMatch then Vector.empty
      else subgraphSpec.outgoingEdges(nodeSpec.name).toVector.map(_.shallowMatchEdges(using snapshot))

  extension (edgeSpec: EdgeSpec)
    def shallowMatchEdges(using snapshot: NodeSnapshot): Vector[SpecNodeMatch] =
      snapshot.edges.view.collect {
        case edge if edgeSpec.isShallowMatch(edge) => SpecNodeMatch(edgeSpec.direction.to.name, edge.other)
      }.toVector

  extension (resolvedMatchEntry: ResolvedMatchEntry)
    def matchKey: SpecNodeMatch = resolvedMatchEntry._1
    def dependentMatches: Dependencies = resolvedMatchEntry._2

    /** For an initial spec-node match, find all the unproven matches in its own dependencies. */
    def unprovenDependenciesFromSelf: Vector[SpecNodeMatch] =
      dependentMatches.flatten.distinct.filter(_ != matchKey)

  extension (resolvedMatches: ResolvedMatches)
    /** All the unproven spec-node matches given a the dependencies for some nodes. */
    def unprovenDependenciesFrom(matchEntries: Vector[ResolvedMatchEntry]): Vector[SpecNodeMatch] =
      matchEntries
        .map(_.dependentMatches)
        .flatMap(_.flatten)
        .distinct
        .filter(!resolvedMatches.contains(_))

object Matcher:

  def make(time: EventTime, graph: Graph, subgraphSpec: SubgraphSpec, nodes: Vector[Node]): UIO[MatcherLive] =
    for
      nodeCache <- MatcherNodeCache.make(graph, nodes)
      dataViewCache <- MatcherSnapshotCache.make(time, nodeCache)
    yield MatcherLive(subgraphSpec, dataViewCache)
